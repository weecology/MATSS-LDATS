---
title: "Leave-one-out all years"
author: "Renata Diaz"
date: "9/10/2019"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(MATSS)
library(matssldats)
library(drake)
library(dplyr)
library(ggplot2)

## Set up the cache and config
db <- DBI::dbConnect(RSQLite::SQLite(), here::here("drake", "drake-cache.sqlite"))
cache <- storr::storr_dbi("datatable", "keystable", db)

loadd(portal_ann_data, cache = cache)

```

```{r load ts models, eval = F}

ts_done <- cached(cache = cache) [ which(grepl("ts_", cached(cache = cache)))]

ts_results <- list()

for(i in 1:length(ts_done)) {
    ts_results[[i]] <- readd(ts_done[i], character_only = T, cache = cache)
}

names(ts_results) <- ts_done

model_info <- all_model_info(ts_results)

save(model_info, file = here::here("analysis", "reports", "model_info.Rds"))

rm(ts_results)
rm(ts_done)

```

```{r load model info}
load(here::here("analysis", "reports", "model_info.Rds"))
```

## Crossval method

- Create 1 dataset for every time step. Each dataset has 1 timestep removed plus the adjacent 2 timesteps in either direction. 
    - RMD went with a 2 timestep buffer based on autocorrelation plots of *total abundance*.
- Fit LDA models with 20 seeds, 3, 6, 9, and 12 topics.
- For every LDA model, run 4 TS models with the usual array of 0 or 1 changepoints and ~ year or ~ 1, for 1000 iterations. 
    - The above steps took about 36 hours on the hipergator. It broke `collect_results` in a mysterious way, but that seems fine(?).
- For every TS model, for every draw from the posterior, calculate the loglikelihood of the observed abundances at the *central withheld timestep* coming from that TS model. Report the mean of these loglikelihoods across all the draws from the posterior.  
- For every combination of *LDA number of topics and seed* and *TS model*, calculate the average loglikelihood across all datasets (the datasets differ in which timesteps are withheld). This gives a performance score for every model configuration like `3 topics, seed 20, 0 changepoints, ~ time`. 

#### Average performance across model seeds:

```{r eval performance over all subgroups}

avg_performance <- model_info %>%
    distinct() %>%
    group_by(k, seed, lda_model_name, lda_model_index, formula, changepoints, ts_model_name, ts_model_index, ts_model_desc, ts_model_desc_k) %>%
    summarize(nmodels = n(),
              mean_testll = mean(testll)) %>%
    ungroup() %>%
    mutate(k = as.factor(k))

avg_performance_plot <- ggplot(data = avg_performance, aes(x = ts_model_desc, y = mean_testll, color = k)) +
    geom_boxplot() +
    theme_bw() +
    ggtitle("LDA seed + TS model performance") +
    ylab("Mean loglikelihood") +
    xlab("Model configuration") +
    scale_color_viridis_d(option = "C", end = .7)

avg_performance_plot
```


#### Zooming in to the highest 10 scores:
```{r best performers}

best_performers <- avg_performance %>%
    arrange(desc(mean_testll)) %>%
    mutate(rank = row_number()) %>%
    filter(rank <= 10)

best_performers_plot <-  ggplot(data = best_performers, aes(x = ts_model_desc, y = mean_testll, color = k)) +
    geom_boxplot() +
    theme_bw() +  
    ggtitle("LDA seed + TS model performance") +
    ylab("Mean loglikelihood") +
    xlab("Model configuration") +
    scale_color_viridis_d(option = "C", end = .7)
best_performers_plot

```


## Best-performing model

```{r best model, fig.height = 3, fig.width=4}

best_model <- best_performers %>%
    filter(rank == 1) %>%
    mutate(k = as.numeric(k)) %>%
    select(lda_model_name, ts_model_desc) %>%
    left_join(model_info) %>%
    distinct()

best_lda_models <- lapply(as.list(best_model$lda_object_name),
                          FUN = readd,
                          character_only = T, 
                          cache = cache)

best_ts_models <- list()
for(i in 1:nrow(best_model)) {
    best_ts_models[[i]] <- readd(best_model$ts_object_name[i], character_only = T, cache = cache)$ts[[best_model$ts_model_index[i]]]
}

for(i in seq(1, 28, by = 7)) {
    
    plot(best_lda_models[[i]]$lda)
  plot(best_ts_models[[i]])
    
}
```

## Predictions from best models 

Method to generate predictions:

- For each number of topics, identify the best-performing LDA seed + TS model configuration with that number of topics over all timesteps of witheld data. There will be one of these models for every timestep, each one fit to all of the data *except* that timestep + a buffer. 
- For each timestep, use the LDA + TS model with that timestep withheld for predictions. 
    - Generate a term-document probability matrix *for all years* using Beta and Eta matrices from a random draw from that model's posterior
    - Sample abundances for *only the central missing year* to get abundances for that timestep. 
- Stitch all these predictions together to make predictions across the full timeseries. 

```{r predictions from best models}
best_performers <- avg_performance %>%
    group_by(k) %>%
    arrange(desc(mean_testll)) %>%
    mutate(rank = row_number()) %>%
    filter(rank == 1) %>%
    ungroup()

predictions <- list()
for(j in c(3, 6, 12)) {
    best_performer <- filter(best_performers, k == j)

best_model_names <- model_info %>%
    distinct() %>%
    filter(ts_model_name == best_performer$ts_model_name[1])

best_ldas <- list()
best_ts_models <- list()
for(i in 1:nrow(best_model_names)) {
    best_ldas[[i]] <- readd(best_model_names$lda_object_name[i], character_only = T, cache = cache)
    best_ts_models[[i]] <- readd(best_model_names$ts_object_name[i], character_only = T, cache = cache)[[1]][[best_model_names$ts_model_index[i]]]
}

predicted_corpuses <- list()

for(i in 1:nrow(best_model_names)) {
    predicted_corpuses[[i]] <- ts_predict_corpus(best_ts_models[[i]], best_ldas[[i]]$lda[[1]],
                                                 data = best_ldas[[i]]$data,
                                                 predict_data = list(abundance = best_ldas[[i]]$data$test_abundance,
                                                                     covariates = best_ldas[[i]]$data$test_covariates))

    names(predicted_corpuses)[i] <- best_ldas[[i]]$data$test_covariates$year
}

predictions[[j]] <- bind_rows(predicted_corpuses, .id = "year") %>%
    select(-timestep) %>%
    mutate(year = as.integer(year)) %>%
    arrange(year)

}

predictions <- predictions[c(3,6,12)]

names(predictions) <- c(3,6,12)

predictions <- bind_rows(predictions, .id = "k")

predictions$k <-as.factor(predictions$k)
```

### Species absolute abundances

```{r abs abund plots, fig.width = 12, fig.height = 20}

abs_plot <- ggplot(data = filter(predictions, source == "pred"), aes(x = year, y = abundance, color = k)) +
    geom_line() +
    geom_line(data = filter(predictions, source == "observed"), aes(x = year, y = abundance), color = "black", alpha = .7) +
        scale_color_viridis_d(option = "C", begin = .2, end = .7) +
    facet_wrap(species ~ ., ncol = 4, scales = "free_y") +
    theme_bw() +
    theme(legend.position = "top")

abs_plot
```

### Species relative abundances


```{r rel abund plots, fig.width = 12, fig.height = 20}

rel_predictions <- predictions %>%
    group_by(year, source, k) %>%
    mutate(total_annual_abund = sum(abundance)) %>%
    ungroup() %>%
    mutate(rel_abundance = abundance / total_annual_abund)

rel_plot <- ggplot(data = filter(rel_predictions, source == "pred"), aes(x = year, y = rel_abundance, color = k)) +
    geom_line() +
    geom_line(data =filter(rel_predictions, source == "observed"), color = "black", alpha = .7) +
        scale_color_viridis_d(option = "C", begin = .2, end = .7) +
    facet_wrap(species ~ ., ncol = 4, scales = "fixed") +
    theme_bw() +
    theme(legend.position = "top")

rel_plot
```

### Relative abundance observed-predicted plots

```{r obs-pred 1:1 plots, fig.width = 10, fig.height = 21}

obspred_dat <- rel_predictions %>%
    select(year, k, source, species, rel_abundance) %>%
    tidyr::spread(key = "source", value = "rel_abundance") %>%
    mutate(k = as.factor(k))

obspred_plot <- ggplot(data = obspred_dat, aes(x = observed, y = pred, color = k)) +
    geom_point() +
    facet_wrap(~ species + k, scales = "free", strip.position = "top", ncol = 6) +
    theme_bw() +
    ylim(min(min(obspred_dat$observed), min(obspred_dat$pred)), max(max(obspred_dat$observed), max(obspred_dat$pred))) +
    xlim(min(min(obspred_dat$observed), min(obspred_dat$pred)), max(max(obspred_dat$observed), max(obspred_dat$pred))) +
    geom_abline(slope = 1, intercept = 0) +
            scale_color_viridis_d(option = "C", begin = .2, end = .7) +
    theme(legend.position = "top")

obspred_plot
```